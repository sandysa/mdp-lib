#ifndef MDPLIB_NEWCOST_H
#define MDPLIB_NEWCOST_H

#include <list>

#include "State.h"
#include "Action.h"
#include "Heuristic.h"

#include "util/general.h"

#include "mini-gpt/problems.h"
#include "mini-gpt/rational.h"
#include "../Problem.h"

namespace CostAdjustment
{
/**
 * An abstract class for Stochastic Shortest Path Problem objects.
 *
 * This class provides pure virtual methods used to implement goal tests,
 * transition functions, cost functions and applicable action tests for a SSP.
 * It also maintains the following information: initial state, discount factor
 * (gamma), list of available actions and an heuristic for the problem.
 *
 * This class also provides an internal set for storing all states that have
 * been generated so far. The method 'addState' is used to populate this set,
 * and it is recommended that classes that inherit from Problem use this method
 * whenever a state is generated by the transition function. This ensures that
 * no duplicate states will be kept in memory. Moreover, the provided
 * destructor will take care of cleaning up all generated states.
 */
typedef std::pair<state_t *, Rational> successor_t;

/**
 * A class representing a PPDDL problem. The implementation is based on
 * the mini-gpt library (see http://ldc.usb.ve/~bonet/reports/JAIR-mgpt.pdf).
 */


class NewCost: public mlppddl::PPDDLProblem
{
private:
    problem_t* pProblem_;

    successor_t display_[DISP_SIZE];

public:

    /*** testing ***/
	virtual void hello(State* s, Action *a) const =0;
	
	 NewCost(problem_t* pProblem);

    virtual ~PPDDLProblem()
    {
        problem_t::unregister_use(pProblem_);
    }

    problem_t* pProblem()  { return pProblem_; }

    /**
     * Overrides method from Problem.
     */
    virtual bool goal(mlcore::State* s) const;

    /**
     * Overrides method from Problem.
     */
    virtual std::list<mlcore::Successor> transition(mlcore::State* s,
                                                    mlcore::Action* a);

    /**
     * Overrides method from Problem.
     */
    virtual double cost(mlcore::State* s, mlcore::Action* a) const;

    /**
     * Overrides method from Problem.
     */
    virtual bool applicable(mlcore::State* s, mlcore::Action* a) const;
	
   };

}

#endif // MDPLIB_NEWCOST_H


